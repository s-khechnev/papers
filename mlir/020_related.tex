% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

\subsection{SSA форма}

Промежуточное представление соответствует SSA \cite{SSA} форме тогда и только тогда, когда каждой переменной значение присваивается ровно один раз.

SSA форма используется во многих современных компиляторах императивных языков программирования, например, в LLVM, HotSpot JVM и GCC. Использование SSA формы значительно упрощает анализ потока управления, поэтому внедрение многих оптимизаций (например, свёртка констант, удаление неиспользуемого кода и удаление общих подвыражений) становится легче.

\subsection{MLIR}

MLIR \cite{MLIR} (Multi-Level Intermediate Representation) --- это гибкая инфраструктура для разработки промежуточных представлений компиляторов на C++. MLIR имеет встроенное (от англ. builtin) промежуточное представление, которое соответствует SSA форме и содержит базовые операции, типы и атрибуты. Из базового промежуточного представления можно создавать собственные промежуточные представления, также в SSA форме, добавляя к базовому промежуточному представлению новые типы и операции, которые могут иметь любую семантику, заданную пользователем.

Далее обзор базовых возможностей MLIR.

\subsubsection{Базовые объекты MLIR}

\begin{itemize}
	\item
	      \textbf{Операции}

	      Операция --- это основная сущность в MLIR. Всё от инструкций до модулей и функций представляется как операция. MLIR позволяет пользователям определять операции.

	      Операция имеет уникальное имя, состоящее из названия диалекта, которому она принадлежит, и идентификатора. Операция имеет нуль или более операндов и результатов. Кроме того, операция может содержать атрибуты, регионы и информацию о местоположении.

	      \begin{lstlisting}[caption={Пример операции.}, frame=single, label={op}]
%res:2 = "mydialect.op"(%arg1, %arg2) { attribute1 = true,
    attribute2 = 1.5} : (tensor<*xf64>, i32) -> (f32, i8)
                     loc(callsite("foo" at "mysrc.e":10:8))
		  \end{lstlisting}

	      На листинге \ref{op} определена абстрактная операция <<op>> из диалекта <<mydialect>>, которая имеет два операнда <<\%arg1>> и <<\%arg2>> типа \texttt{tensor$<$*xf64$>$} (безранговый тензор с элементами типа \texttt{float64}) и \texttt{int32} соответственно; два именованных атрибута: <<attribute1>> со значением \texttt{true}, <<attribute2>> со значением \texttt{1.5}; два результата типа \texttt{float32} и \texttt{int8} соответственно. А также операция имеет информацию о местоположении в исходном тексте программы.

	\item
	      \textbf{Атрибуты}

	      Атрибут --- это любая compile-time константа, которая прикреплена к операции. Любая операция имеет словарь именованных атрибутов, у которого ключ --- имя атрибута, значение --- атрибут. Пользователь может определять собственные атрибуты.

	\item
	      \textbf{Типы}

	      Каждое значение в MLIR имеет тип. Система типов в MLIR полностью расширяема.

	      MLIR предоставляет базовые типы. Например, целочисленные типы, типы с плавающей точкой, строки, кортежи, многомерные вектора, тензоры.

	\item
	      \textbf{Блоки и регионы}

	      Блок --- это список операций, который заканчивается операцией-терминатором. Блоки образуют граф потока управления программы (от англ. control flow graph). В MLIR для поддержания SSA формы вместо использования $\phi$-узлов (как например в LLVM IR) используются аргументы блоков (терминатор блока непосредственно передаёт значения в аргументы следующего блока).

	      Регион --- это список блоков. Любая операция может содержать регионы. При помощи регионов в MLIR реализована вложенная структура: регион содержит список блоков, а блоки содержат список операций, которые, в свою очередь, могут содержать регионы.

	\item
	      \textbf{Диалекты}

	      Диалект в MLIR --- это пространство имён (от англ. namespace) для операций, типов и атрибутов, при помощи которого MLIR поддерживает расширяемость.

	      Базовое промежуточное представление MLIR это не что иное, как диалект, который называется <<builtin>>\footnote{\url{https://mlir.llvm.org/docs/Dialects/Builtin/} (дата доступа:   \DTMdate{2024-01-04}).}.

	      В репозитории MLIR также содержится множество других диалектов\footnote{\url{https://mlir.llvm.org/docs/Dialects/} (дата доступа:   \DTMdate{2024-01-04}).}.
\end{itemize}

\subsubsection{TableGen}

MLIR стремится сделать определение новых диалектов и операций, а также правил переписывания (от англ. rewrite rules\footnote{\url{https://mlir.llvm.org/docs/DeclarativeRewrites/} (дата доступа:   \DTMdate{2024-01-05}).}) паттернов в IR (Intermediate Representation) простым. Для этого MLIR предоставляет декларативный DSL (Domain Specific Language) --- TableGen\footnote{\url{https://mlir.llvm.org/docs/DefiningDialects/Operations/} (дата доступа:   \DTMdate{2024-01-04}).}, из которого генерируется \Cpp{}.

Для того, чтобы определить свой диалект необходимо лишь определить класс, который наследуется от базового класса <<Dialect>>. Внутри класса определить имя, краткое описание, полное описание диалекта и имя для пространства имён диалекта в \Cpp{}.

\begin{lstlisting}[caption={Пример определения диалекта <<MyDialect>>, при помощи TableGen.}, frame=single]
def MyDialect : Dialect {
    let name = "myDialect";

    let summary = "My dialect.";
    let description = [{ My cool dialect. }];

    let cppNamespace = "myDialect";
}
\end{lstlisting}

\begin{lstlisting}[caption={Пример определения операции сложения тензоров, при помощи TableGen.}, label={op_tblgen}, frame=single, mathescape=true]
def TransposeOp : Op<MyDialect, "transpose", [Pure]> {
    let summary = "transpose operation";
    let description = [{
            The op takes tensor and returns same tensor
            with reversed shape.
    }];

    let arguments = (ins F64Tensor:$\mbox{\$}$arg);
    let results = (outs F64Tensor);

    let assemblyFormat = [{
        "(" $\mbox{\$}$arg ":" type($\mbox{\$}$arg) ")" attr-dict "to" type(results)
    }];
}
\end{lstlisting}

Для определения операции необходимо указать какому диалекту принадлежит операция, задать уникальное имя (в рамках диалекта), список признаков (от англ. traits), которые задают поведение операции, аргументы, атрибуты и результаты операции. Также операция может содержать краткое и полное описание, из которого можно сгенерировать документацию для операции (в формате Markdown). Кроме того, для операции можно определять красивый вывод (от англ. pretty print), указывать на наличие верификаторов операции, которые можно определять в \Cpp{}.

На листинге \ref{op_tblgen} приведён пример определения операции диалекта <<MyDialect>>, которая моделирует транспонирование тензоров с элементами типа \texttt{float64}. Операция называется <<transpose>> и имеет признак <<pure>>, означающий, что операция детерминирована и не имеет побочных эффектов. Кроме этого, операция имеет красивый вывод.

\begin{lstlisting}[caption={Пример вывода операции, определённой на листинге \ref{op_tblgen}, без переопределённого вывода.}, frame=single]
%1 = "myDialect.transpose"(%0):(tensor<2x3xf64>)->tensor<3x2xf64>
\end{lstlisting}

\begin{lstlisting}[caption={Пример вывода операции, определённой на листинге \ref{op_tblgen}, с переопределённым выводом.}, frame=single]
%1 = myDialect.transpose(%0 : tensor<2x3xf64>) to tensor<3x2xf64>
\end{lstlisting}

\textbf{Правила переписывания}

TableGen позволяет декларативно определять правила переписывания\footnote{\url{https://mlir.llvm.org/docs/DeclarativeRewrites/} (дата доступа:   \DTMdate{2024-01-05}).} шаблонов в IR.

\begin{lstlisting}[caption={Базовый класс для шаблона.}, frame=single]
class Pattern<
    dag sourcePattern, list<dag> resultPatterns,
    list<dag> additionalConstraints = [],
    list<dag> supplementalPatterns = [],
    dag benefitsAdded = (addBenefit 0)>;
\end{lstlisting}

Правило переписывания содержит две главные компоненты: исходный паттерн и итоговый паттерн. При применении правила исходный паттерн в IR будет заменён на итоговый паттерн.

\textbf{Пример}

Так как применение чётного количество раз операции транспонирования к тензору это тождественное преобразование, то можно определить правило переписывания, которое будет заменять вызов чётного числа транспонирования некоторого тензора на данный тензор.

\begin{lstlisting}[caption={Пример создания правила переписывания для операции, определённой на листинге \ref{op_tblgen}}, label={rewrite_pat}, frame=single]
// transpose(transpose(x)) -> x
def RedundantTransposeOptPattern :
  Pattern<(TransposeOp(TransposeOp $\mbox{\$}$arg)),
          [(replaceWithValue $\mbox{\$}$arg)]>;
\end{lstlisting}

Правило переписывания на листинге \ref{rewrite_pat} находит в IR двойной вызов операции <<myDialect.transpose>> от некоторого аргумента, захватывает аргумент первого вызова и заменяет эту последовательность на аргумент первого вызова.

\subsection{Взаимодействие OCaml с C}

Далее будет кратко рассказано как код, написанный на языке C можно вызывать из OCaml. Более подробно написано здесь\footnote{\url{https://v2.ocaml.org/manual/intfc.html} (дата доступа:   \DTMdate{2024-01-04}).}.

\subsubsection{Объявление}

Для того чтобы объявить внешнюю функцию, в \OCaml{} существует ключевое слово <<external>>.
\begin{lstlisting}[caption={Синтаксис объявления внешней функции.},language=Caml, frame=single]
external name : type = C-function-name
\end{lstlisting}

\begin{lstlisting}[caption={Пример объявления внешней функции <<print\_int>>, которая ссылается на функцию, определённую в С, с именем <<caml\_print\_int>>.},language=Caml, frame=single]
external print_int : int -> unit = "caml_print_int"
\end{lstlisting}

\subsubsection{Определение}

С функция должна принимать столько же аргументов, сколько и в объявлении внешней функции (если количество аргументов больше 5, то см. здесь\footnote{\url{https://v2.ocaml.org/manual/intfc.html\#ss:c-prim-impl} (дата доступа:   \DTMdate{2024-01-04}).}), типа \texttt{value} и возвращать значение типа \texttt{value}. Тип \texttt{value} служит для представления \OCaml{} типа.

\begin{lstlisting}[caption={Содержимое файла C с определением функции <<caml\_print\_int>>.}, language=C, frame=single]
#include <stdio.h>
#include <caml/mlvalues.h>

CAMLprim value caml_print_int(value val)
{
    int num = Int_val(val);
    printf("%d\n", num);
    return Val_unit;
}
\end{lstlisting}

Заголовочный файл <<caml/mlvalues.h>> предоставляет макросы для преобразования значений \OCaml{}-типа в тип \C{} и наоборот. Функция <<print\_int>>, определённая на стороне \OCaml{}, принимает \texttt{int} и возвращает \texttt{unit}, поэтому аргумент функции <<caml\_\-pri\-nt\-\_int>> типа \texttt{value} представляет из себя целое число. <<Int\_val>> преобразует значение типа \texttt{value} в значение С-типа \texttt{int}. Ожидается, что функция вернёт \texttt{unit}, поэтому функция <<caml\_\-pri\-nt\-\_int>> возвращает значение <<Val\_unit>>.

Таким образом, когда внешняя функция вызывается в \OCaml{}, вызывается функция \C{} с переданными аргументами. Затем значение, возвращаемое функцией, передается обратно в \OCaml{} как результат вызова функции.

Реализация внешней функции представляет из себя две задачи:
\begin{enumerate}
	\item декодирование аргументов для извлечения значений \C{} из значений \OCaml{} и кодирование возвращаемого значения как \OCaml{}-значения;
	\item фактическое вычисление какого-то результата из аргументов.
\end{enumerate}

Предпочтительно иметь две отдельные функции \C{} для реализации этих двух задач:

\begin{itemize}
	\item первая функция реализует основную логику функции, принимая и возвращая значения \C{};
	\item вторая --- часто называемая <<заглушкой>> (от англ. stub), представляет собой простую обёртку вокруг первой функции, которая преобразует свои аргументы из значений \OCaml{} в значения \C{}, вызывает первую функцию и преобразует возвращаемое значение \C{} в значение \OCaml{}.
\end{itemize}

\begin{lstlisting}[caption={Функция <<print\_int>> --- реализует логику, функция <<caml\_print\_int>> --- заглушка}, language=C, frame=single, label={qwe}]
void print_int(int num) {
   printf("%d\n", num);
   return;
}

CAMLprim value caml_print_int(value val)
{
    print_int(Int_val(num));
    return Val_unit;
}
\end{lstlisting}

\subsubsection{Линковка}

Существует два вида линковки \OCaml{} с \C{}:

\begin{enumerate}
	\item динамическая;
	\item статическая.
\end{enumerate}

Особенности динамической линковки:
\begin{enumerate}
	\item сохраняет независимость исполняемых файлов, скомпилированных в байт-код, от платформы;
	\item размер исполняемого файла меньше чем при статической линковки;
	\item пользователям библиотеки не нужно иметь компилятор и линковщик \C{}, а также runtime библиотеки \C{};
	\item итоговый исполняемый файл не является автономным (от англ. standalone): на машине должны быть библиотеки;
\end{enumerate}

\subsection{Ctypes}
\label{sec:ctypes}

Ctypes\footnote{\url{https://github.com/yallop/ocaml-ctypes} (дата доступа:   \DTMdate{2024-01-04}).} --- это \OCaml{} библиотека для создания привязок к \C{}. Основная цель библиотеки --- сделать создание привязок к \C{} максимально простым. Используя эту библиотеку, больше не нужно писать <<заглушки>> на С{}.

Так, например, для того чтобы вызвать из \OCaml{} ранее определённую на листинге \ref{qwe} функцию <<print\_int>>, необходимо предоставить имя функции, описать сигнатуру функции при помощи предоставляемых <<ctypes>> комбинаторов и слинковать \C{} и \OCaml{}.

\begin{lstlisting}[caption={Привязка к функции <<print\_int>>, определённой на листинге \ref{qwe}, при помощи <<ctypes>>}, language=Caml, frame=single, label ={ctypes_example}]
let print_int = foreign "print_int" (int @-> returning void)
\end{lstlisting}

\subsubsection{Линковка}

Существует два способа линковки привязок:

\begin{enumerate}
	\item динамическая;
	\item статическая генерация привязок.
\end{enumerate}

При динамической линковке ctypes использует библиотеку <<libffi>>\footnote{\url{https://github.com/libffi/libffi} (дата доступа:   \DTMdate{2024-01-04}).} для динамического открытия библиотек \C{}, поиска соответствующих символов вызываемой функции и упорядочивания аргументов функции в соответствии с ABI (Application Binary Interface) операционной системы. Многое из этого происходит <<под капотом>> ctypes, однако такой подход имеет следующие минусы:

\begin{itemize}
	\item понижение безопасности: библиотеки \C{} не содержат информацию о типах функций, которые они содержат, поэтому не существует способа проверить соответствуют ли переданные типы в <<foreign>> фактическим типам связываемой функции;
	\item накладные расходы на интерпретацию.
\end{itemize}

К счастью, ctypes предоставляет альтернативный способ линковки привязок --- статический. В этом случае линковка выполняется один раз во время сборки, вместо того, чтобы выполнять её при каждом вызове функции. При статической линковке:
\begin{enumerate}
	\item Используя те же описания функций, как на листинге \ref{ctypes_example}, генерируется .ml файл, который содержит объявления внешних функций, и .c файл с заглушками;
	\item .ml и .c компилируются и линкуются в одну библиотеку;
\end{enumerate}

\subsection{Существующие решения}

На просторах \GitHub{} была найдена попытка\footnote{\url{https://github.com/tachukao/ocaml-mlir} (дата доступа:   \DTMdate{2024-01-04}).} создания привязок к MLIR для \OCaml{}. Данные привязки создавались к форку\footnote{\url{https://github.com/tachukao/llvm-project} (дата доступа:   \DTMdate{2024-01-05}).} MLIR, базирующемуся на древней версии MLIR --- одиннадцатой, не примитивного примера использования привязок в репозитории не было, и на момент начала работы репозиторий был заброшен. Показалось, что использование некоторой базы может сильно сэкономить время, поэтому эти привязки были взяты за основу.

% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Эксперимент (желательно к Новому году)}
Как мы проверяем, что  всё удачно получилось.  К Новому году для промежуточного отчета желательно хотя бы описать как он будет прово\-диться и на чем.

\subsection{Условия эксперимента}
Железо (если актуально);  версии ОС, компиляторов и параметры командной строки; почему мы выбрали именно эти тесты; входные дан\-ные, на которых проверяем наш подход, и почему мы выбрали именно их.

\subsection{Исследовательские вопросы }
По-английски называется \emph{research questions}, в тексте можно ссылаться на них как RQ1, RQ2, и т.~д.
Необходимо сформулировать, чего мы хотели бы добиться работой (2 пункта будет хорошо):

\begin{itemize}
\item Хотим алгоритм, который лучше вот таких-то остальных.
\item Если в подходе можно включать/выключать составляющие, то насколько существенно каждая составляющая влияет на улучшения.
\item Если у нас строится приближение каких-то штук, то на сколько точными будут эти приближения.
\item и т.п.
\end{itemize}

Иногда в работах это называют гипотезами, которые потом проверяют. Далее в тексте можно ссылаться на research questions как \textsc{RQ}, это обще\-при\-нятое сокращение.

\subsection{Метрики}

Как мы сравниваем, что результаты двух подходов лучше или хуже:
\begin{itemize}
\item Производительность.
\item Строчки кода.
\item Как часто алгоритм \enquote{угадывает} правильную класси\-фикацию входа.
\end{itemize}

\noindent Иногда метрики вырожденные (да/нет), это не очень хорошо, но если в области исследований так принято, то ладно.

\subsection{Результаты}
Результаты понятно что такое. Тут всякие таблицы и графики, как в таблице \ref{time_cmp_obj_func}. Обратите внимание, как цифры выровнены по правому краю, названия по центру, а разделители $\times$ и $\pm$ друг под другом.

Скорее всего Ваши измерения будут удовлетворять нормальному распределению, в идеале это надо проверять с помощью критерия Кол\-могорова и т.п.
Если критерий этого не подтверждает, то у Вас что-то сильно не так с измерениями, надо проверять кэши процессора, отключать Интернет во время измерений, подкручивать среду исполне\-ния (англ. runtime), что\-бы сборка мусора не вмешивалась и т.п.
Если критерий удовлетворён, то необходимо либо указать мат. ожидание и доверительный/предсказы\-вающий интервал, либо написать, что все измерения проводились с погрешностью, например, в 5\%.
Замечание: если у вас получится улуч\-шение производительности в пределах погреш\-ности, то это обязательно вызовет вопросы.

В этом разделе надо также коснуться Research Questions.

\subsubsection{RQ1} Пояснения
\subsubsection{RQ2} Пояснения

\begin{table}
\def\arraystretch{1.1}  % Растяжение строк в таблицах
\setlength\tabcolsep{0.2em}
\centering
% \resizebox{\linewidth}{!}{%
    \caption{Производительность какого-то алгоритма при различных разрешениях картинок  (меньше~--- лучше), в мс.,  CI=0.95. За пример таблички кидаем чепчики в честь Я.~Кириленко}
    \begin{tabular}[C]{
    S[table-format=4.4,output-decimal-marker=\times]
    *4{S
          [table-figures-uncertainty=2, separate-uncertainty=true, table-align-uncertainty=true,
          table-figures-integer=3, table-figures-decimal=2, round-precision=2,
          table-number-alignment=center]
          }
    }
    \toprule
        \multicolumn{1}{r}{Resolution} & \multicolumn{1}{r}{\textsc{TENG}} & \multicolumn{1}{r}{\textsc{LAPM}} &
        \multicolumn{1}{r}{\textsc{VOLL4}} \\ \midrule
        1920.1080 & 406.23 \pm 0.94 & 134.06 \pm 0.35 & 207.45 \pm 0.42  \\ \midrule
        1024.768  & 145.0 \pm 0.47  & 39.68 \pm 0.1   &  52.79  \pm 0.1 \\ \midrule
        464.848   & 70.57 \pm 0.2   & 19.86 \pm 0.01     & 32.75  \pm 0.04 \\ \midrule
        640.480   & 51.10 \pm 0.2   & 14.70 \pm 0.1 & 24  \pm 0.04 \\ \midrule
        160.120   & 2.4 \pm 0.02    & 0.67 \pm 0.01      & 0.92  \pm 0.01 \\
        \bottomrule
    \end{tabular}%
%}
    \label{time_cmp_obj_func}
\end{table}

\clearpage
\input{figures/bigtable}

\subsection{Обсуждение результатов}

Чуть более неформальное обсуждение, то, что сделано. Например, почему метод работает лучше остальных? Или, что делать со случаями, когда метод классифицирует вход некорректно.
